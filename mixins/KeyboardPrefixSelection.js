/**
 * Handle list box-style prefix typing, in which the user can type a string to
 * select the first item that begins with that string.
 *
 * @element basic-keyboard-prefix-selection
 *
 */

import Composable from 'element-base/extensible/Composable';

// TODO: If the selection is changed by some other means (e.g., arrow keys) other
// than prefix typing, then that act should reset the prefix.

export default class KeyboardPrefixSelection {

  // itemsChanged() {
  //   this._itemTextContents = null;
  //   resetTypedPrefix(this);
  // }

  keydown(event) {
    let handled;
    let resetPrefix = true;

    switch (event.keyCode) {
      case 8: // Backspace
        handleBackspace(this);
        handled = true;
        resetPrefix = false;
        break;
      case 27: // Escape
        handled = true;
        break;
      default:
        if (!event.ctrlKey && !event.metaKey && !event.altKey
          && event.which !== 32 /* Space */) {
          handlePlainCharacter(this, String.fromCharCode(event.which));
        }
        resetPrefix = false;
    }

    if (resetPrefix) {
      resetTypedPrefix(this);
    }

    return handled;
  }

  /**
   * Select the first item whose text content begins with the given prefix.
   *
   * @method selectItemWithTextPrefix
   * @param prefix [String] The string to search for
   */
  selectItemWithTextPrefix(prefix) {
    if (prefix == null || prefix.length === 0) {
      return;
    }
    let index = getIndexOfItemWithTextPrefix(this, prefix);
    if (index >= 0) {
      this.selectedIndex = index;
    }
  }

}
Composable.decorate.call(KeyboardPrefixSelection.prototype, {
  keydown: Composable.rule(Composable.rules.preferMixinResult)
});


// Time in milliseconds after which the user is considered to have stopped
// typing.
const PREFIX_TIMEOUT_DURATION = 1000;


// Return the index of the first item with the given prefix, else -1.
function getIndexOfItemWithTextPrefix(element, prefix) {
  let itemTextContents = getItemTextContents(element);
  let prefixLength = prefix.length;
  for (let i = 0; i < itemTextContents.length; i++) {
    let itemTextContent = itemTextContents[i];
    if (itemTextContent.substr(0, prefixLength) === prefix) {
      return i;
    }
  }
  return -1;
}

// Return an array of the text content (in lowercase) of all items.
// Cache these results.
function getItemTextContents(element) {
  if (!element._itemTextContents) {
    let items = element.items;
    element._itemTextContents = items.map(child => {
      let text = child.textContent || child.alt;
      return text.toLowerCase();
    });
  }
  return element._itemTextContents;
}

function handleBackspace(element) {
  let length = element._typedPrefix ? element._typedPrefix.length : 0;
  if (length > 0) {
    element._typedPrefix = element._typedPrefix.substr(0, length - 1);
  }
  element.selectItemWithTextPrefix(element._typedPrefix);
  element._setPrefixTimeout();
}

function handlePlainCharacter(element, char) {
  let prefix = element._typedPrefix || '';
  element._typedPrefix = prefix + char.toLowerCase();
  element.selectItemWithTextPrefix(element._typedPrefix);
  setPrefixTimeout(element);
}

function resetPrefixTimeout(element) {
  if (element._prefixTimeout) {
    clearTimeout(element._prefixTimeout);
    element._prefixTimeout = false;
  }
}

function resetTypedPrefix(element) {
  element._typedPrefix = '';
  resetPrefixTimeout(element);
}

function setPrefixTimeout(element) {
  resetPrefixTimeout(element);
  element._prefixTimeout = setTimeout(() => {
    resetTypedPrefix(element);
  }, PREFIX_TIMEOUT_DURATION);
}
